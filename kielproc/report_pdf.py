from __future__ import annotations
from pathlib import Path
from datetime import datetime
import json
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages


def _fig_cover(outdir: Path, summary_path: Path) -> plt.Figure:
    s = {}
    try:
        s = json.loads(Path(summary_path).read_text())
    except Exception:
        pass
    meta_path = Path(outdir) / "transmitter_lookup_meta.json"
    flow_meta = {}
    try:
        flow_meta = json.loads(meta_path.read_text())
    except Exception:
        pass

    fig = plt.figure(figsize=(8.27, 11.69))  # A4 portrait
    ax = fig.add_axes([0,0,1,1]); ax.axis("off")
    lines = []
    lines.append("KielProc — Mill PA Differential Validation Report")
    lines.append("")
    lines.append(f"Generated: {datetime.now().isoformat(timespec='seconds')}")
    if s:
        lines.append(f"Site: {s.get('site_name','')}")
        bp = s.get("baro_pa", None)
        if isinstance(bp, (int, float)):
            bs = s.get("baro_source", {})
            src = bs.get("source", "")
            extra = f" ({bs.get('cell','')}, {bs.get('unit_raw','')})" if src == "workbook" else ""
            lines.append(f"Barometric pressure: {bp:.0f} Pa  [{src}{extra}]")
        lines.append(f"Input mode: {s.get('input_mode','')}")
        lines.append(f"Prepared input: {s.get('prepared_input_dir','')}")
        if s.get("beta") is not None or s.get("r") is not None:
            lines.append(f"β: {s.get('beta')}    r: {s.get('r')}")
    if flow_meta:
        cal = flow_meta.get("calibration", {})
        lines.append("")
        lines.append(f"Season: {flow_meta.get('season','')}")
        if cal:
            lines.append(f"UIC K (t/h per √mbar): {cal.get('K_uic','')}")
            lines.append(f"820 m (t/h/mbar): {cal.get('m_820','')}   c (t/h): {cal.get('c_820','')}")
            lines.append(f"Calibration source: {cal.get('source','')}")
    ax.text(0.08, 0.92, "\n".join(lines), va="top", ha="left", fontsize=12, family="monospace")
    ax.text(0.08, 0.06, "Generated by kielproc.run_easy.run_all()", fontsize=9)
    return fig


def _fig_per_port_table(per_port_csv: Path) -> plt.Figure | None:
    p = Path(per_port_csv)
    if not p.exists(): return None
    df = pd.read_csv(p)
    # Choose a compact subset if available
    prefer = [c for c in ["Port","VP_pa_mean","T_C_mean","Static_abs_pa_mean","q_s_pa","w_s","w_t"] if c in df.columns]
    view = df[prefer] if prefer else df
    fig = plt.figure(figsize=(11.69, 8.27))  # A4 landscape
    ax = fig.add_axes([0.03, 0.03, 0.94, 0.92]); ax.axis("off")
    ax.set_title("Per-port summary", loc="left")
    tbl = ax.table(cellText=view.values[:20], colLabels=view.columns, loc="center")
    tbl.auto_set_font_size(False); tbl.set_fontsize(8); tbl.scale(1.0, 1.2)
    return fig


def _fig_flow_reference_with_overlay(outdir: Path) -> plt.Figure | None:
    ref = Path(outdir) / "transmitter_lookup_reference.csv"
    if not ref.exists(): return None
    dref = pd.read_csv(ref)
    fig = plt.figure(figsize=(11.69, 8.27)); ax = fig.add_subplot(111)
    ax.plot(dref["ref_DP_mbar"], dref["ref_Flow_UIC_tph"], label="UIC (√DP) – reference")
    ax.plot(dref["ref_DP_mbar"], dref["ref_Flow_820_tph"], label="820 (linear) – reference")
    data = Path(outdir) / "transmitter_lookup_data.csv"
    if data.exists():
        dd = pd.read_csv(data)
        if {"data_DP_mbar","data_Flow_UIC_tph","data_Flow_820_tph"}.issubset(dd.columns):
            ax.scatter(dd["data_DP_mbar"], dd["data_Flow_UIC_tph"], s=12, alpha=0.7, label="UIC – data")
            ax.scatter(dd["data_DP_mbar"], dd["data_Flow_820_tph"], s=12, alpha=0.7, label="820 – data")
    ax.set_xlabel("DP (mbar)"); ax.set_ylabel("Flow (t/h)")
    ax.set_title("Flow lookup: reference (constant) with data overlay")
    ax.grid(True, linestyle="--", alpha=0.4); ax.legend()
    return fig


def _fig_venturi_curve(outdir: Path) -> plt.Figure | None:
    curve_csv = Path(outdir) / "venturi_curve.csv"
    vjson = Path(outdir) / "venturi_result.json"
    df = None
    if curve_csv.exists():
        df = pd.read_csv(curve_csv)
    elif vjson.exists():
        try:
            v = json.loads(vjson.read_text())
            df = pd.DataFrame(v.get("curve", []))
        except Exception:
            df = None
    if df is None or not {"frac_of_Qs","dp_vent_Pa"}.issubset(df.columns):
        return None
    fig = plt.figure(figsize=(11.69, 8.27))
    ax = fig.add_subplot(111)
    ax.plot(df["frac_of_Qs"], df["dp_vent_Pa"], marker="o")
    ax.set_xlabel("Fraction of Qs"); ax.set_ylabel("Venturi Δp (Pa)")
    ax.set_title("Venturi Δp vs Flow"); ax.grid(True, linestyle="--", alpha=0.4)
    return fig


def _fig_setpoints(outdir: Path) -> plt.Figure | None:
    csv = Path(outdir) / "transmitter_setpoints.csv"
    if not csv.exists(): return None
    df = pd.read_csv(csv)
    needed = {"UIC_percent","Y820"}
    if not needed.issubset(df.columns): return None
    fig = plt.figure(figsize=(11.69, 8.27))
    ax = fig.add_subplot(111)
    ax.plot(df.index, df["UIC_percent"], label="UIC %")
    ax.plot(df.index, df["Y820"], label="820")
    ax.set_xlabel("Sample index"); ax.set_ylabel("Output")
    ax.set_title("Transmitter outputs (from logger)"); ax.grid(True, linestyle="--", alpha=0.4); ax.legend()
    return fig


def build_run_report_pdf(
    outdir: Path,
    summary_path: Path,
    filename: str = "RunReport.pdf",
) -> Path:
    outdir = Path(outdir); outdir.mkdir(parents=True, exist_ok=True)
    pdf_path = outdir / filename
    with PdfPages(pdf_path) as pdf:
        # Cover
        pdf.savefig(_fig_cover(outdir, summary_path)); plt.close()
        # Per-port table
        f = _fig_per_port_table(outdir / "per_port.csv")
        if f: pdf.savefig(f); plt.close()
        # Flow reference (constant) + data overlay (optional)
        f = _fig_flow_reference_with_overlay(outdir)
        if f: pdf.savefig(f); plt.close()
        # Venturi curve (optional)
        f = _fig_venturi_curve(outdir)
        if f: pdf.savefig(f); plt.close()
        # Setpoints plot (optional)
        f = _fig_setpoints(outdir)
        if f: pdf.savefig(f); plt.close()
    return pdf_path


__all__ = ["build_run_report_pdf"]

